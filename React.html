<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>
    <script>
        // 练习ES6继承：
        // 创建父类：
        class Person{
            // 在父类里面添加属性：
            constructor(name,gender,age){
                this.name=name,
                this.gender=gender,
                this.age=age
            }
            // 添加父类方法：
            eat(){
                alert("人类都会吃");
            }
        }
        // 实例化一个父类对象：
        let p1 = new Person("石鹏飞","男",21);
        console.log(p1);
        // 创建子类，并继承父类的属性及方法
        class Child extends Person{// 继承了父类元素上的原型方法
            constructor(name,gender,age,sno,sdet){
                super(name,gender,age);// 调用父类构造器函数，为创建的子类元素添加父类的属性
                this.sno = sno;
                this.sdet = sdet;
            }
            study(){
                alert("Child的原型上的方法");
            }
        }
        // 实例化一个继承出来的对象
        let c1 = new Child("迪迦","男",3000,1001,"光系战士");
        console.log(c1);
    </script>
</head>
<body>
    --大中型公司主流技术：
        1、React技术栈；
        2、Vue技术栈
    优势：组件化、模块化开发，将UI或功能分割成更小的代码片段(组件)，可以实现代码的高度服用，开发和维护效率较高，成本低！

                                第一章：React入门
    一、React简介：
        1、React起源于Facebook的内部项目，用来架设Instagram的网站，并与2013年5月开源
        2、react所属公司：“ facebook ”——做社交网站的
        3、facebooke想开发一个图片分享网站“Instagram”(类似于微博)，认为市面上的框架不满足需求
            开发需求：spa 单页应用——整个应用只有一个页面，通过地址栏路由切换实现组件状态切换
    二、React开发方向：
        ①：web         react
        ②：类原生 App   react native
    三、react特点：
        ①：较高的性能；
            --虚拟DOM——js对象，减少DOM刷新次数
            --diff算法——对比之前DOM树和之后DOM树，进行局部刷新
        ②：虚拟DOM；
        ③：组件化——代码的高度复用
        ④：JSX语法——快速生成虚拟DOM——通过babel-loader
        ⑤：单项相应的数据流：父组件——>子组件，单向的

    四、React操作真实DOM
        ReactDOM.render(
            <App />,
            document.getElementById("app")
        )
        相当于：document.getElementById("app").innerHTML = <App />组件渲染完生成的真实DOM对象

    五、jsx语法：在js中通过xml/xhtml代码快速生成虚拟DOM语法的写法
    六、react jsx语法，遵循xml/xhtml标准
        1、属性的值要加双引号；
        2、单标记必须关闭；
        3、只能有一个根元素
        4、标记只能等嵌套，不能交叉

    七、jsx模板语法：{}，在jsx中写js变量或表达式
        1、{} 模板中，用条件表达式代替if-else

    八、jsx中关键字冲突：
        1、htmlFor 代替 for
        2、className 代替 class
        3、defaultValue 代替 value

    九、jsx模板中的数组：
        1、jsx模板会自动遍历数组 {数组}

    十、数组API ES5——react
        1、数组元素遍历：map
            let 新数组 = 数组.map((value,index)=>{
                // 代码
                return 新的数组元素
            })
        2、数组元素过滤：filter
            let 新数组 = 数组.map((value,index)=>{
                // 代码
                return true(元素保留)/false(元素删除)
            })

    十一、属性类型检查：
        问题：父给子组件传递数据，对this.props数据进行类型检查——能够减少错误发生
            子组件想要number类型，结果不小心给了string类型造成了BUG
        React@15.5以前版本 Prop-types 内置到React里面；
        React@15.5以后版本，包括15.5版本 prop-types不在内置到React，成为了第三方包

                            第二章：React组件
    一、React简介：
            React组件将UI分割成独立的可复用的片段，这些片段都有各自隔离的作用域，不会互相干扰，
        可以将组件理解为类似函数的概念，组件从它的props属性接收参数

    二、React组件分类：都要学
        1、函数式无状态组件/静态组件——所有版本都支持：现在的新项目在使用(无状态组件+hooks)
        2、类组件：新老项用到，老项目偏多
            ①：ES5原生方式React.createClass定义的组件 react 16不支持
            ②：ES6形式的extends React.Component定义的组件 react 16支持

    三、props state说明
        Props 属性：组件对外的接口 { props.name:"tom" } <App name="tom"/>
        state 状态：组件对内接口，组件自身状态改变，就是修改了state，也就是this.state
      说明：想要自己重新render，就改变自己的this.state；
            别人想让我改变，改变这个组件的props/this.props

    四、函数式无状态组件/静态组件
        三无：
            1、无this   this指向undefined
            2、无state  没有状态
            3、无生命周期方法
        
    五、子组件：在一个组件中渲染的组件就是子组件
        funtion Zujian(){
            return(
                <div>
                    <Child /> // Child就是子组件
                </div>
            );
        }

    六、类组件
        1、ES5方式创建类组件——react@16不支持
            学习的原因：
                (1)老项目的维护
                (2)更好的学习生命组件的生命周期方法
              说明：ES5中是没有类的概念的
        2、ES6方式创建类组件——react@16+支持

    七、组件生命周期(lifeCycle)方法：在组建挂载(创建)、更新、卸载过程中按照固定顺序自动调用的钩子函数——hock函数
 
    八、组件生命周期方法
        分为三个阶段
            第一阶段：初始化阶段/挂载阶段——mounted
                ①：getDefaultProps()：初始化this.props，如果和<组件 属性="值"/>发生冲突，name被覆盖
                ②：getInitialState()：初始化this.state
                ③：componentWillMount：挂在前——后面的版本废弃了
                ④：render：挂载——进行模板计算：jsx——>babel-loader——>虚拟DOM——>方法调用完返回真实DOM
                    说明：render中无法得到真实DOM对象
                ⑤：componentDidMount：挂载后
                    说明：获取真实DOM对象、操纵真实DOM对象、执行ajax
            第二阶段：更新阶段——update：props/this.props和this.state发生改变
                ⑥：componentWillReceiveProps：将要接受新的props
                ⑦：shouldComponentUpdate：判断是否进入更新阶段——
                    说明：父类中的shouldComponentUpdate并没有具体实现这个方法功能，不管this.porps和this.state是否
                          发生改变，都会返回true，并进入更新阶段
    ————————————————>面试题：shouldComponentUpdate这个方法是干什么用呢？
                    答：1、ES6可以使用PureComponent实现对象浅层比较，对组件进行性能优化——开发中使用较多
                        2、可以自己写算法实现shouldComponentUpdate方法，对组件进行优化！
                ⑧：componentWillUpdate：将要进行更新
                    再次调用render——上面的第四步
                ⑨：componentDidUpdate：更新完成
            第三阶段：卸载阶段——unmounted
                ⑩：componentWillWillUnmount：将要卸载组件

    九、如何创建组件ES5：
        React.createClass({
            方法2:function(){},
            方法2:function(){}
        })
        创建的类从React父类继承了三个属性和10个生命周期方法
        三个属性：都是只读的
            --this.props对外接口    谁让我从新render，谁给我传改变了的this.props
            --this.state对内接口    自己想要从新render
                ——如果想修改this.state值，只能通过异步方法this.setState()
            --this.refs DOM对象的集合{ref值:真实DOM对象,ref值:真实DOM对象}
        十个生命周期方法

    十、React中的事件不是JS原生事件，是对原生事件进行封装后的
        1、     JS原生事件                  React事件
                onclick                     onClick
                onchange                    onChange——相当于原生oninput

    十一、React中如何获取真实DOM对象？
        1、如果获取的是触发事件的这个DOM对象——使用事件对象.target
        2、通过ref属性获取
            {ref属性名:DOM对象,ref属性名:DOM对象}
            this.refs.ref属性名获取DOM对象
        3、原生代码获取：不推荐

                            第三章：diff算法、this.setState
    一、ES6创建类组件,react@16+
        
    二、React@16.3新增了3个生命周期方法代替旧方法——React@16.3 新旧写法都支持
            旧方法                                      新方法
    ①componentWillMount                     UNSAFE_componentWillMount
    ②componentWillReceiveProps              UNSAFE_componentWillReceiveProps
    ③componentWillUpdate                    UNSAFE_componentWillUpdate
      说明：从React@16.4 开始，使用旧方法，开发模式，就会有警告
      说明：从React@17.0.2 新旧方法都支持，以后的版本旧方法就废弃了
        
    三、ES6类组件生命周期分为三个阶段
        第一阶段：初始化阶段
            1、UNSAFE_componentWillMount 将要挂载——挂载前
            2、render 挂载
            3、componentDidMount 挂载后——可以进行多种操作
        第二阶段：更新阶段
            4、UNSAFE_componentWillReceiveProps 将要接受props
            5、shouldComponentUpdate 判断是否进入更新阶段
                功能：对组件进行性能优化
                问题：父类Component类，提供的shouldComponentUpdate并没有实现这个方法，默认只返回true
                     不管this.props或this.state是否发生改变变都会进入更新阶段，就会重新调用render进行
                     挂载——性能较低
                解决：类组件如何进行性能优化？
                    ① 父类换成PureComponent，实现了shouldComponentUpdate方法，会对this.props和this.state的浅层比较
                    ② 如果数据层级很多，需要自己去写算法实现shouldComponentUpdate方法，来判断this.props/this.state是否发生改变，
                      再决定是否进入更新阶段
            6、UNSAFE_componentWillUpdate 更新前
            7、componentDidUpdate 更新后
        第三阶段：卸载阶段
            8、componentWillUnmount 将要卸载
            

                                    diff算法：React渲染机制
    一、React渲染过程：
           在页面一开始打开的时候，React会调用render函数构建一颗DOM树，在state/props发生改变的时候，render函数会被再次调用渲染出
        另外一颗树，接着，React会用两棵树进行比对，找到需要更新的地方进行批量改动。

    二、diff算法
        这个过程中比较两颗DOM树高效找出更新的地方是很重要的。React基于两个假设：
            1、两个相同的组件产生类似的DOM解构，不同组件产生不同DOM结构
            2、对于同一层次的一组子节点，它们可以通过唯一的key值区分
        说明：diff算法极大地优化了这个比较的过程，将算法复杂度从n^3变为了n。

    三、diff算法具体操作
        --分为两种情况：
            1、节点类型不同；
                例：<A><c/></A>  ——>  <B><C/></B>
            2、节点类型相同，但是属性/值不同
            3、列表比较

                            this.setState说明——是异步操作
    一、如何简化ES6的类组件写法
        问题：我们发现ES6类组件写起来非常冗余，维护困难，代码量大
            --每个类要用state就得写constructor和super
            --只要有处理函数，就得写静态绑定
        解决：@babel/plugin-proposal-class-properties 简化react组建的写法
          说明：因为在搭建webpack环境的时候，语法插件都是最新的，已经内置这个插件了，不需要再安装了

    二、数组方法：reduce()可以计算数组内的数值型总和
        例：
            let arr = [1,2,5,8,3,1];
            arr.reduce((prev,cur,index)=>{
                console.log(prev,cur,index)
                return prev+cur;
            })
            最后返回的是数组内的数值总合
      说明：this.setState的回调函数就是这个原理






</body>
</html>